---
import Navigation from '../components/Navigation.astro';
import Footer from '../components/Footer.astro';
import Background from '../components/Background.astro';
import '../styles/global.css';

export interface Props {
  title: string;
  description?: string;
}

const { title, description = "A minimalist personal blog" } = Astro.props;
---

<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width" />
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
    <meta name="generator" content={Astro.generator} />
    <meta name="description" content={description} />
    <title>{title}</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  </head>
  <body class="bg-white dark:bg-brand-background text-zinc-900 dark:text-brand-text min-h-screen flex flex-col">
    <!-- Page transition overlay - for smooth transitions between pages -->
    <div id="page-transition" class="fixed inset-0 z-40 bg-white dark:bg-brand-background opacity-0 pointer-events-none transition-opacity duration-300 flex items-center justify-center">
      <div class="transition-spinner"></div>
    </div>
    
    <!-- Background component with dot pattern and ambient glow -->
    <Background />
    
    <div class="max-w-3xl mx-auto px-4 sm:px-6 w-full flex-grow">
      <Navigation />
      <main class="py-12">
        <slot />
      </main>
    </div>
    <Footer />
    
    <script>
      // Robust SPA transition system
      document.addEventListener('DOMContentLoaded', () => {
        console.log('SPA system initializing...');
        
        const pageTransition = document.getElementById('page-transition');
        const mainContent = document.querySelector('main');
        
        // Ensure content is visible on initial load
        if (mainContent) {
          mainContent.style.opacity = '1';
          mainContent.style.transform = 'translateY(0)';
          console.log('Content visibility ensured');
        }
        
        // SPA transition function
        async function loadContent(url) {
          try {
            console.log('🔄 Loading content for:', url);
            
            // Show transition overlay
            if (pageTransition) {
              pageTransition.classList.remove('opacity-0', 'pointer-events-none');
              pageTransition.classList.add('opacity-100');
              console.log('Transition overlay shown');
            }
            
            // Fetch the new page content
            const response = await fetch(url);
            if (!response.ok) throw new Error(`Failed to fetch ${url}`);
            const html = await response.text();
            console.log('✅ Content fetched successfully');
            
            // Parse HTML
            const parser = new DOMParser();
            const doc = parser.parseFromString(html, 'text/html');
            
            // Extract content
            const newContent = doc.querySelector('main');
            const newTitle = doc.querySelector('title');
            
            if (!newContent) throw new Error('Could not find main content');
            
            // Update title
            if (newTitle) {
              document.title = newTitle.textContent;
              console.log('📄 Title updated:', newTitle.textContent);
            }
            
            // Wait for transition
            await new Promise(resolve => setTimeout(resolve, 300));
            
            // Replace content
            if (mainContent) {
              mainContent.innerHTML = newContent.innerHTML;
              console.log('🔄 Content replaced');
              
              // Execute scripts
              Array.from(newContent.querySelectorAll('script')).forEach(oldScript => {
                const newScript = document.createElement('script');
                Array.from(oldScript.attributes).forEach(attr => {
                  newScript.setAttribute(attr.name, attr.value);
                });
                newScript.textContent = oldScript.textContent;
                document.head.appendChild(newScript);
              });
              console.log('📜 Scripts executed');
            }
            
            // Hide transition overlay
            if (pageTransition) {
              setTimeout(() => {
                pageTransition.classList.add('opacity-0', 'pointer-events-none');
                pageTransition.classList.remove('opacity-100');
                console.log('✅ Transition complete');
              }, 200);
            }
            
            // Scroll to top
            window.scrollTo(0, 0);
            
            // Re-attach listeners
            attachLinkListeners();
            
          } catch (error) {
            console.error('❌ Error loading content:', error);
            
            // Hide transition overlay
            if (pageTransition) {
              pageTransition.classList.add('opacity-0', 'pointer-events-none');
              pageTransition.classList.remove('opacity-100');
            }
            
            // Fallback to traditional navigation
            console.log('🔄 Falling back to traditional navigation');
            window.location.href = url;
          }
        }
        
        // Function to attach event listeners to all links
        function attachLinkListeners() {
          console.log('🔗 Attaching link listeners...');
          const links = document.querySelectorAll('a');
          console.log(`Found ${links.length} links`);
          
          links.forEach((link, index) => {
            // Skip links that are already handled
            if (link.hasAttribute('data-spa-handled')) {
              return;
            }
            
            // Skip external links
            if (!link.href.startsWith(window.location.origin)) {
              return;
            }
            
            // Skip anchor links
            if (link.href.includes('#')) {
              return;
            }
            
            // Skip links with special attributes
            if (link.hasAttribute('target') || link.hasAttribute('download')) {
              return;
            }
            
            // Skip external rel links
            if (link.getAttribute('rel') === 'external' || link.getAttribute('rel') === 'nofollow') {
              return;
            }
            
            // Mark as handled to avoid duplicate listeners
            link.setAttribute('data-spa-handled', 'true');
            
            link.addEventListener('click', (e) => {
              console.log(`🖱️ Link clicked: ${link.href}`);
              
              // Don't handle if modifier keys are pressed
              if (e.metaKey || e.ctrlKey || e.shiftKey || e.altKey) {
                console.log('Modifier key pressed, skipping SPA');
                return;
              }
              
              e.preventDefault();
              const targetHref = link.href;
              
              // Don't transition if clicking the current page
              if (targetHref === window.location.href) {
                console.log('Same page, skipping transition');
                return;
              }
              
              console.log('🚀 Starting SPA transition to:', targetHref);
              
              // Update browser history
              window.history.pushState({ path: targetHref }, '', targetHref);
              
              // Load the new content
              loadContent(targetHref);
            });
          });
          
          console.log('✅ Link listeners attached');
        }
        
        // Initial attachment of link listeners
        attachLinkListeners();
        
        // Handle browser back/forward navigation
        window.addEventListener('popstate', (e) => {
          console.log('🔄 Browser navigation detected');
          if (e.state && e.state.path) {
            loadContent(e.state.path);
          } else {
            loadContent(window.location.href);
          }
        });
        
        console.log('✅ SPA system initialized');
      });
      
      // Theme handling with transition effects
      function setupThemeHandling() {
        // Apply theme from localStorage or system preference
        const theme = localStorage.getItem('theme');
        if (theme === 'dark' || (!theme && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
          document.documentElement.classList.add('dark');
        } else {
          document.documentElement.classList.remove('dark');
        }
        
        // Listen for theme changes
        document.addEventListener('themeChanged', () => {
          // Add transition class to body
          document.body.classList.add('theme-transitioning');
          
          // Remove class after transition completes
          setTimeout(() => {
            document.body.classList.remove('theme-transitioning');
          }, 500);
        });
      }
      
      // Initialize theme handling
      document.addEventListener('DOMContentLoaded', setupThemeHandling);
      
      // Ensure content visibility on every page load
      function ensureContentVisibility() {
        const mainContent = document.querySelector('main');
        if (mainContent) {
          mainContent.style.opacity = '1';
          mainContent.style.transform = 'translateY(0)';
          mainContent.style.transition = 'opacity 0.3s ease, transform 0.3s ease';
        }
      }
      
      // Enhanced content visibility with error recovery
      function robustContentVisibility() {
        const mainContent = document.querySelector('main');
        if (mainContent) {
          console.log('Ensuring content visibility...');
          
          // Method 1: Reset all inline styles
          mainContent.style.cssText = '';
          
          // Method 2: Force visibility with multiple methods
          mainContent.style.opacity = '1';
          mainContent.style.transform = 'translateY(0)';
          mainContent.style.transition = 'opacity 0.3s ease, transform 0.3s ease';
          mainContent.style.display = 'block';
          mainContent.style.visibility = 'visible';
          mainContent.style.position = 'relative';
          mainContent.style.zIndex = '1';
          mainContent.style.width = '100%';
          mainContent.style.height = 'auto';
          mainContent.style.minHeight = 'auto';
          
          // Method 3: Remove any problematic classes
          mainContent.classList.remove('content-entering', 'content-hidden', 'opacity-0', 'hidden');
          
          // Method 4: Force a reflow to ensure styles are applied
          mainContent.offsetHeight;
          
          // Method 5: Additional verification
          setTimeout(() => {
            if (mainContent.style.opacity !== '1' || mainContent.style.display !== 'block') {
              console.warn('Content visibility issue detected, forcing visibility');
              mainContent.style.opacity = '1';
              mainContent.style.transform = 'translateY(0)';
              mainContent.style.display = 'block';
              mainContent.style.visibility = 'visible';
            }
          }, 50);
          
          console.log('Content visibility ensured');
        } else {
          console.warn('Main content element not found');
        }
      }
      
      // Run on every page load with multiple event listeners
      document.addEventListener('DOMContentLoaded', robustContentVisibility);
      document.addEventListener('astro:page-load', robustContentVisibility);
      document.addEventListener('spa-content-loaded', robustContentVisibility);
      
      // Additional fallback: ensure visibility every 500ms for the first 10 seconds
      let visibilityCheckCount = 0;
      const visibilityInterval = setInterval(() => {
        robustContentVisibility();
        visibilityCheckCount++;
        if (visibilityCheckCount >= 20) {
          clearInterval(visibilityInterval);
        }
      }, 500);
      
      // Emergency fallback: check visibility on window focus
      window.addEventListener('focus', robustContentVisibility);
      
      // Additional fallback: check visibility on scroll
      window.addEventListener('scroll', () => {
        const mainContent = document.querySelector('main');
        if (mainContent && mainContent.style.opacity !== '1') {
          console.warn('Content visibility issue detected on scroll, fixing');
          robustContentVisibility();
        }
      });
    </script>
  </body>
</html>

<style>
  /* Enhanced page transition effects */
  #page-transition {
    transition: opacity 0.3s ease;
    backdrop-filter: blur(4px);
  }
  
  /* Transition spinner animation */
  .transition-spinner {
    width: 30px;
    height: 30px;
    border: 2px solid rgba(0, 0, 0, 0.1);
    border-radius: 50%;
    border-top-color: #3B82F6;
    animation: spin 0.7s linear infinite;
  }
  
  :global(.dark) .transition-spinner {
    border-color: rgba(226, 232, 240, 0.1);
    border-top-color: #10B981;
  }
  
  @keyframes spin {
    to { transform: rotate(360deg); }
  }
  
  /* Content entrance animation */
  main {
    opacity: 1;
    transform: translateY(0);
    transition: opacity 0.5s ease, transform 0.5s ease;
  }
  
  main.content-entering {
    animation: content-fade-in 0.6s ease forwards;
  }
  
  @keyframes content-fade-in {
    from {
      opacity: 0;
      transform: translateY(10px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }
  
  /* Theme transition effect */
  body.theme-transitioning * {
    transition-duration: 0.3s !important;
  }
</style>