---
export interface Props {
  children: any;
  delay?: number;
  direction?: 'up' | 'down' | 'left' | 'right' | 'fade';
  duration?: number;
}

const { children, delay = 0, direction = 'up', duration = 600 } = Astro.props;

const directionClasses = {
  up: 'translate-y-8',
  down: '-translate-y-8',
  left: 'translate-x-8',
  right: '-translate-x-8',
  fade: 'opacity-0'
};

const directionClassesTo = {
  up: 'translate-y-0',
  down: 'translate-y-0',
  left: 'translate-x-0',
  right: 'translate-x-0',
  fade: 'opacity-100'
};
---

<div 
  class={`scroll-reveal opacity-0 ${directionClasses[direction]} transition-all duration-${duration} ease-out`}
  data-delay={delay}
  data-direction={direction}
  data-duration={duration}
>
  {children}
</div>

<style>
  .scroll-reveal {
    transition-property: opacity, transform;
    transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
  }
  
  .scroll-reveal.revealed {
    opacity: 1 !important;
    transform: translate(0, 0) !important;
  }
  
  /* Intersection Observer fallback */
  @supports not (intersection-observer: 1) {
    .scroll-reveal {
      opacity: 1 !important;
      transform: translate(0, 0) !important;
    }
  }
</style>

<script>
  document.addEventListener('DOMContentLoaded', () => {
    const revealElements = document.querySelectorAll('.scroll-reveal');
    
    if (!revealElements.length) return;
    
    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          const element = entry.target;
          const delay = parseInt(element.dataset.delay) || 0;
          
          setTimeout(() => {
            element.classList.add('revealed');
          }, delay);
          
          observer.unobserve(element);
        }
      });
    }, {
      threshold: 0.1,
      rootMargin: '0px 0px -50px 0px'
    });
    
    revealElements.forEach(element => {
      observer.observe(element);
    });
  });
</script>
